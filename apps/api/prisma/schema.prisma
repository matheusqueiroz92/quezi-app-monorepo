// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ========================================
// ENUMS
// ========================================

enum UserType {
  CLIENT
  PROFESSIONAL
}

enum ServicePriceType {
  FIXED
  HOURLY
}

enum ServiceMode {
  AT_LOCATION   // Atendimento no local próprio do profissional
  AT_DOMICILE   // Atendimento a domicílio do cliente
  BOTH
}

enum AppointmentStatus {
  PENDING
  ACCEPTED
  REJECTED
  COMPLETED
}

enum OrganizationRole {
  OWNER    // Dono da organização (salão/empresa)
  ADMIN    // Administrador (gerente)
  MEMBER   // Membro/Profissional da equipe
}

enum InviteStatus {
  PENDING
  ACCEPTED
  REJECTED
  EXPIRED
}

// ========================================
// ENTIDADES / MODELS
// ========================================

model User {
  id              String   @id @default(uuid()) @db.Uuid
  email           String   @unique
  passwordHash    String?
  name            String
  phone           String?
  userType        UserType
  isEmailVerified Boolean  @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relações
  professionalProfile    ProfessionalProfile?   // 1:1, opcional (apenas para UserType: PROFESSIONAL)
  clientAppointments     Appointment[]          @relation("ClientAppointments")
  profAppointments       Appointment[]          @relation("ProfessionalAppointments")
  reviews                Review[]
  ownedOrganizations     Organization[]         @relation("OrganizationOwner")
  organizationMemberships OrganizationMember[]
  sentInvites            OrganizationInvite[]   @relation("InviteSender")

  @@map("users")
}

model ProfessionalProfile {
  userId        String      @id @db.Uuid
  bio           String?
  city          String
  address       String?
  serviceMode   ServiceMode // NOVO CAMPO: AT_LOCATION, AT_DOMICILE, BOTH
  averageRating Float       @default(0.0)
  totalRatings  Int         @default(0)
  photoUrl      String?
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  // Relações
  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  services Service[]

  @@map("professional_profiles")
}

model Category {
  id        String    @id @default(uuid()) @db.Uuid
  name      String    @unique
  slug      String    @unique
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  services  Service[]

  @@map("categories")
}

model Service {
  id              String           @id @default(uuid()) @db.Uuid
  professionalId  String           @db.Uuid
  categoryId      String           @db.Uuid
  name            String
  description     String?
  price           Decimal          @db.Money
  priceType       ServicePriceType
  durationMinutes Int // NOVO CAMPO: Duração do Serviço em Minutos
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  // Relações
  professional ProfessionalProfile @relation(fields: [professionalId], references: [userId], onDelete: Cascade)
  category     Category            @relation(fields: [categoryId], references: [id])
  appointments Appointment[]

  @@map("services")
}

model Appointment {
  id            String            @id @default(uuid()) @db.Uuid
  clientId      String            @db.Uuid
  professionalId String           @db.Uuid
  serviceId     String            @db.Uuid
  scheduledDate DateTime
  status        AppointmentStatus @default(PENDING)
  locationType  ServiceMode // NOVO CAMPO: LOCAL_PROPRIO ou DOMICILIO (Tipo de ServiceMode)
  clientAddress String? // Endereço de atendimento se for a domicílio
  clientNotes   String?
  isReviewed    Boolean           @default(false)
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  // Relações
  client       User    @relation("ClientAppointments", fields: [clientId], references: [id])
  professional User    @relation("ProfessionalAppointments", fields: [professionalId], references: [id])
  service      Service @relation(fields: [serviceId], references: [id])
  review       Review? // 1:1 (um agendamento pode ter uma review)

  @@index([professionalId, scheduledDate]) // Índice para checagem rápida de agendamentos
  @@map("appointments")
}

model Review {
  id             String   @id @default(uuid()) @db.Uuid
  appointmentId  String   @unique @db.Uuid // 1:1, única por agendamento
  reviewerId     String   @db.Uuid
  professionalId String   @db.Uuid
  rating         Int // Será validado na aplicação: rating > 0 AND rating <= 5
  comment        String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relações
  appointment Appointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  reviewer    User        @relation(fields: [reviewerId], references: [id])

  @@map("reviews")
}

// ========================================
// ORGANIZAÇÕES (Salões, Clínicas, Empresas)
// ========================================

model Organization {
  id          String   @id @default(uuid()) @db.Uuid
  name        String
  slug        String   @unique
  description String?
  ownerId     String   @db.Uuid
  logoUrl     String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relações
  owner   User                 @relation("OrganizationOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  members OrganizationMember[]
  invites OrganizationInvite[]

  @@map("organizations")
}

model OrganizationMember {
  id             String           @id @default(uuid()) @db.Uuid
  organizationId String           @db.Uuid
  userId         String           @db.Uuid
  role           OrganizationRole
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt

  // Relações
  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([organizationId, userId]) // Um usuário só pode ter uma role por organização
  @@index([userId])
  @@map("organization_members")
}

model OrganizationInvite {
  id             String       @id @default(uuid()) @db.Uuid
  organizationId String       @db.Uuid
  email          String
  role           OrganizationRole
  invitedBy      String       @db.Uuid
  status         InviteStatus @default(PENDING)
  expiresAt      DateTime // Convite expira em 7 dias
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt

  // Relações
  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  inviter      User         @relation("InviteSender", fields: [invitedBy], references: [id])

  @@unique([organizationId, email]) // Não permitir convites duplicados
  @@index([email])
  @@map("organization_invites")
}
